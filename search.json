[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "talks/Scoring rules/index.html",
    "href": "talks/Scoring rules/index.html",
    "title": "Scaling of scoring rules",
    "section": "",
    "text": "&lt;div id=\"quarto-navigation-envelope\" class=\"hidden\"&gt;\n&lt;p&gt;&lt;span class=\"hidden\" data-render-id=\"quarto-int-sidebar-title\"&gt;Jonas Wallin&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-int-navbar-title\"&gt;Jonas Wallin&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-int-navbar:Publications\"&gt;Publications&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-int-navbar:/publications/index.html\"&gt;/publications/index.html&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-int-navbar:Online talks\"&gt;Online talks&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-int-navbar:/talks/index.html\"&gt;/talks/index.html&lt;/span&gt;&lt;/p&gt;\n&lt;div class=\"hidden\" data-render-id=\"footer-left-Copyright 2023, Jonas Wallin\"&gt;\n&lt;p&gt;Copyright 2023, Jonas Wallin&lt;/p&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;div id=\"quarto-meta-markdown\" class=\"hidden\"&gt;\n&lt;p&gt;&lt;span class=\"hidden\" data-render-id=\"quarto-metatitle\"&gt;Jonas Wallin - Scaling of scoring rules&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-twittercardtitle\"&gt;Jonas Wallin - Scaling of scoring rules&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-ogcardtitle\"&gt;Jonas Wallin - Scaling of scoring rules&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-metasitename\"&gt;Jonas Wallin&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-twittercarddesc\"&gt;A talk about scaling of scoring rules (model evaluation)&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-ogcardddesc\"&gt;A talk about scaling of scoring rules (model evaluation)&lt;/span&gt;&lt;/p&gt;\n&lt;/div&gt;\n\n&lt;/main&gt; &lt;!-- /main --&gt;\n&lt;script id = \"quarto-html-after-body\" type=\"application/javascript\"&gt;\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const toggleBodyColorMode = (bsSheetEl) =&gt; {\n    const mode = bsSheetEl.getAttribute(\"data-mode\");\n    const bodyEl = window.document.querySelector(\"body\");\n    if (mode === \"dark\") {\n      bodyEl.classList.add(\"quarto-dark\");\n      bodyEl.classList.remove(\"quarto-light\");\n    } else {\n      bodyEl.classList.add(\"quarto-light\");\n      bodyEl.classList.remove(\"quarto-dark\");\n    }\n  }\n  const toggleBodyColorPrimary = () =&gt; {\n    const bsSheetEl = window.document.querySelector(\"link#quarto-bootstrap\");\n    if (bsSheetEl) {\n      toggleBodyColorMode(bsSheetEl);\n    }\n  }\n  toggleBodyColorPrimary();  \n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const isCodeAnnotation = (el) =&gt; {\n    for (const clz of el.classList) {\n      if (clz.startsWith('code-annotation-')) {                     \n        return true;\n      }\n    }\n    return false;\n  }\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    text: function(trigger) {\n      const codeEl = trigger.previousElementSibling.cloneNode(true);\n      for (const childEl of codeEl.children) {\n        if (isCodeAnnotation(childEl)) {\n          childEl.remove();\n        }\n      }\n      return codeEl.innerText;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    var currentTitle = button.getAttribute(\"title\");\n    button.setAttribute(\"title\", \"Copied!\");\n    let tooltip;\n    if (window.bootstrap) {\n      button.setAttribute(\"data-bs-toggle\", \"tooltip\");\n      button.setAttribute(\"data-bs-placement\", \"left\");\n      button.setAttribute(\"data-bs-title\", \"Copied!\");\n      tooltip = new bootstrap.Tooltip(button, \n        { trigger: \"manual\", \n          customClass: \"code-copy-button-tooltip\",\n          offset: [0, -8]});\n      tooltip.show();    \n    }\n    setTimeout(function() {\n      if (tooltip) {\n        tooltip.hide();\n        button.removeAttribute(\"data-bs-title\");\n        button.removeAttribute(\"data-bs-toggle\");\n        button.removeAttribute(\"data-bs-placement\");\n      }\n      button.setAttribute(\"title\", currentTitle);\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {\n    const config = {\n      allowHTML: true,\n      maxWidth: 500,\n      delay: 100,\n      arrow: false,\n      appendTo: function(el) {\n          return el.parentElement;\n      },\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start',\n    };\n    if (contentFn) {\n      config.content = contentFn;\n    }\n    if (onTriggerFn) {\n      config.onTrigger = onTriggerFn;\n    }\n    if (onUntriggerFn) {\n      config.onUntrigger = onUntriggerFn;\n    }\n    window.tippy(el, config); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i&lt;noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      // use id or data attribute instead here\n      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');\n      try { href = new URL(href).hash; } catch {}\n      const id = href.replace(/^#\\/?/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  const xrefs = window.document.querySelectorAll('a.quarto-xref');\n  const processXRef = (id, note) =&gt; {\n    // Strip column container classes\n    const stripColumnClz = (el) =&gt; {\n      el.classList.remove(\"page-full\", \"page-columns\");\n      if (el.children) {\n        for (const child of el.children) {\n          stripColumnClz(child);\n        }\n      }\n    }\n    stripColumnClz(note)\n    if (id === null || id.startsWith('sec-')) {\n      // Special case sections, only their first couple elements\n      const container = document.createElement(\"div\");\n      if (note.children && note.children.length &gt; 2) {\n        container.appendChild(note.children[0].cloneNode(true));\n        for (let i = 1; i &lt; note.children.length; i++) {\n          const child = note.children[i];\n          if (child.tagName === \"P\" && child.innerText === \"\") {\n            continue;\n          } else {\n            container.appendChild(child.cloneNode(true));\n            break;\n          }\n        }\n        if (window.Quarto?.typesetMath) {\n          window.Quarto.typesetMath(container);\n        }\n        return container.innerHTML\n      } else {\n        if (window.Quarto?.typesetMath) {\n          window.Quarto.typesetMath(note);\n        }\n        return note.innerHTML;\n      }\n    } else {\n      // Remove any anchor links if they are present\n      const anchorLink = note.querySelector('a.anchorjs-link');\n      if (anchorLink) {\n        anchorLink.remove();\n      }\n      if (window.Quarto?.typesetMath) {\n        window.Quarto.typesetMath(note);\n      }\n      // TODO in 1.5, we should make sure this works without a callout special case\n      if (note.classList.contains(\"callout\")) {\n        return note.outerHTML;\n      } else {\n        return note.innerHTML;\n      }\n    }\n  }\n  for (var i=0; i&lt;xrefs.length; i++) {\n    const xref = xrefs[i];\n    tippyHover(xref, undefined, function(instance) {\n      instance.disable();\n      let url = xref.getAttribute('href');\n      let hash = undefined; \n      if (url.startsWith('#')) {\n        hash = url;\n      } else {\n        try { hash = new URL(url).hash; } catch {}\n      }\n      if (hash) {\n        const id = hash.replace(/^#\\/?/, \"\");\n        const note = window.document.getElementById(id);\n        if (note !== null) {\n          try {\n            const html = processXRef(id, note.cloneNode(true));\n            instance.setContent(html);\n          } finally {\n            instance.enable();\n            instance.show();\n          }\n        } else {\n          // See if we can fetch this\n          fetch(url.split('#')[0])\n          .then(res =&gt; res.text())\n          .then(html =&gt; {\n            const parser = new DOMParser();\n            const htmlDoc = parser.parseFromString(html, \"text/html\");\n            const note = htmlDoc.getElementById(id);\n            if (note !== null) {\n              const html = processXRef(id, note);\n              instance.setContent(html);\n            } \n          }).finally(() =&gt; {\n            instance.enable();\n            instance.show();\n          });\n        }\n      } else {\n        // See if we can fetch a full url (with no hash to target)\n        // This is a special case and we should probably do some content thinning / targeting\n        fetch(url)\n        .then(res =&gt; res.text())\n        .then(html =&gt; {\n          const parser = new DOMParser();\n          const htmlDoc = parser.parseFromString(html, \"text/html\");\n          const note = htmlDoc.querySelector('main.content');\n          if (note !== null) {\n            // This should only happen for chapter cross references\n            // (since there is no id in the URL)\n            // remove the first header\n            if (note.children.length &gt; 0 && note.children[0].tagName === \"HEADER\") {\n              note.children[0].remove();\n            }\n            const html = processXRef(null, note);\n            instance.setContent(html);\n          } \n        }).finally(() =&gt; {\n          instance.enable();\n          instance.show();\n        });\n      }\n    }, function(instance) {\n    });\n  }\n      let selectedAnnoteEl;\n      const selectorForAnnotation = ( cell, annotation) =&gt; {\n        let cellAttr = 'data-code-cell=\"' + cell + '\"';\n        let lineAttr = 'data-code-annotation=\"' +  annotation + '\"';\n        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';\n        return selector;\n      }\n      const selectCodeLines = (annoteEl) =&gt; {\n        const doc = window.document;\n        const targetCell = annoteEl.getAttribute(\"data-target-cell\");\n        const targetAnnotation = annoteEl.getAttribute(\"data-target-annotation\");\n        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));\n        const lines = annoteSpan.getAttribute(\"data-code-lines\").split(\",\");\n        const lineIds = lines.map((line) =&gt; {\n          return targetCell + \"-\" + line;\n        })\n        let top = null;\n        let height = null;\n        let parent = null;\n        if (lineIds.length &gt; 0) {\n            //compute the position of the single el (top and bottom and make a div)\n            const el = window.document.getElementById(lineIds[0]);\n            top = el.offsetTop;\n            height = el.offsetHeight;\n            parent = el.parentElement.parentElement;\n          if (lineIds.length &gt; 1) {\n            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);\n            const bottom = lastEl.offsetTop + lastEl.offsetHeight;\n            height = bottom - top;\n          }\n          if (top !== null && height !== null && parent !== null) {\n            // cook up a div (if necessary) and position it \n            let div = window.document.getElementById(\"code-annotation-line-highlight\");\n            if (div === null) {\n              div = window.document.createElement(\"div\");\n              div.setAttribute(\"id\", \"code-annotation-line-highlight\");\n              div.style.position = 'absolute';\n              parent.appendChild(div);\n            }\n            div.style.top = top - 2 + \"px\";\n            div.style.height = height + 4 + \"px\";\n            div.style.left = 0;\n            let gutterDiv = window.document.getElementById(\"code-annotation-line-highlight-gutter\");\n            if (gutterDiv === null) {\n              gutterDiv = window.document.createElement(\"div\");\n              gutterDiv.setAttribute(\"id\", \"code-annotation-line-highlight-gutter\");\n              gutterDiv.style.position = 'absolute';\n              const codeCell = window.document.getElementById(targetCell);\n              const gutter = codeCell.querySelector('.code-annotation-gutter');\n              gutter.appendChild(gutterDiv);\n            }\n            gutterDiv.style.top = top - 2 + \"px\";\n            gutterDiv.style.height = height + 4 + \"px\";\n          }\n          selectedAnnoteEl = annoteEl;\n        }\n      };\n      const unselectCodeLines = () =&gt; {\n        const elementsIds = [\"code-annotation-line-highlight\", \"code-annotation-line-highlight-gutter\"];\n        elementsIds.forEach((elId) =&gt; {\n          const div = window.document.getElementById(elId);\n          if (div) {\n            div.remove();\n          }\n        });\n        selectedAnnoteEl = undefined;\n      };\n        // Handle positioning of the toggle\n    window.addEventListener(\n      \"resize\",\n      throttle(() =&gt; {\n        elRect = undefined;\n        if (selectedAnnoteEl) {\n          selectCodeLines(selectedAnnoteEl);\n        }\n      }, 10)\n    );\n    function throttle(fn, ms) {\n    let throttle = false;\n    let timer;\n      return (...args) =&gt; {\n        if(!throttle) { // first call gets through\n            fn.apply(this, args);\n            throttle = true;\n        } else { // all the others get throttled\n            if(timer) clearTimeout(timer); // cancel #2\n            timer = setTimeout(() =&gt; {\n              fn.apply(this, args);\n              timer = throttle = false;\n            }, ms);\n        }\n      };\n    }\n      // Attach click handler to the DT\n      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');\n      for (const annoteDlNode of annoteDls) {\n        annoteDlNode.addEventListener('click', (event) =&gt; {\n          const clickedEl = event.target;\n          if (clickedEl !== selectedAnnoteEl) {\n            unselectCodeLines();\n            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');\n            if (activeEl) {\n              activeEl.classList.remove('code-annotation-active');\n            }\n            selectCodeLines(clickedEl);\n            clickedEl.classList.add('code-annotation-active');\n          } else {\n            // Unselect the line\n            unselectCodeLines();\n            clickedEl.classList.remove('code-annotation-active');\n          }\n        });\n      }\n  const findCites = (el) =&gt; {\n    const parentEl = el.parentElement;\n    if (parentEl) {\n      const cites = parentEl.dataset.cites;\n      if (cites) {\n        return {\n          el,\n          cites: cites.split(' ')\n        };\n      } else {\n        return findCites(el.parentElement)\n      }\n    } else {\n      return undefined;\n    }\n  };\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i&lt;bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const citeInfo = findCites(ref);\n    if (citeInfo) {\n      tippyHover(citeInfo.el, function() {\n        var popup = window.document.createElement('div');\n        citeInfo.cites.forEach(function(cite) {\n          var citeDiv = window.document.createElement('div');\n          citeDiv.classList.add('hanging-indent');\n          citeDiv.classList.add('csl-entry');\n          var biblioDiv = window.document.getElementById('ref-' + cite);\n          if (biblioDiv) {\n            citeDiv.innerHTML = biblioDiv.innerHTML;\n          }\n          popup.appendChild(citeDiv);\n        });\n        return popup.innerHTML;\n      });\n    }\n  }\n});\n&lt;/script&gt;\n&lt;/div&gt; &lt;!-- /content --&gt;\n&lt;footer class=\"footer\"&gt;\n  &lt;div class=\"nav-footer\"&gt;\n    &lt;div class=\"nav-footer-left\"&gt;\n      &lt;ul class=\"footer-items list-unstyled\"&gt;\n    &lt;li class=\"nav-item\"&gt;\n Copyright 2023, Jonas Wallin\n  &lt;/li&gt;  \n&lt;/ul&gt;\n    &lt;/div&gt;   \n    &lt;div class=\"nav-footer-center\"&gt;\n      &nbsp;\n    &lt;/div&gt;\n    &lt;div class=\"nav-footer-right\"&gt;\n      &lt;ul class=\"footer-items list-unstyled\"&gt;\n    &lt;li class=\"nav-item compact\"&gt;\n    &lt;a class=\"nav-link\" href=\"https://github.com/JonasWallin\"&gt;\n      &lt;i \n  class=\"bi bi-github\" \n  role=\"img\" \n&gt;\n&lt;/i&gt; \n    &lt;/a&gt;\n  &lt;/li&gt;  \n&lt;/ul&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/footer&gt;\n\n\n&lt;/body&gt;\n\n&lt;/html&gt;\nCitationBibTeX citation:@unpublished{wallin2020,\n  author = {Wallin, Jonas and Bolin, David},\n  title = {Scaling of Scoring Rules},\n  date = {2020-06-08},\n  url = {https://www.cirm-math.com/cirm-virtual-event-2146.html},\n  langid = {en},\n  abstract = {Averages of proper scoring rules are often used to rank\n    probabilistic forecasts. In many cases, the individual observations\n    and their predictive distributions in these averages have variable\n    scale (variance). I will show that some of the most popular proper\n    scoring rules, such as the continuous ranked probability score\n    (CRPS), up-weight observations with large uncertainty which can lead\n    to unintuitive rankings. We have developed a new scoring rule,\n    scaled CRPS (SCRPS), this new proper scoring rule is locally scale\n    invariant and therefore works in the case of varying uncertainty. I\n    will demostrate this how this affects model selection through\n    parameter estimation in spatial statitics.}\n}\nFor attribution, please cite this work as:\nWallin, Jonas, and David Bolin. 2020. “Scaling of Scoring\nRules.” Online, Online, June 8. https://www.cirm-math.com/cirm-virtual-event-2146.html."
  },
  {
    "objectID": "talks/index.html",
    "href": "talks/index.html",
    "title": "Online talks",
    "section": "",
    "text": "Predicting the Swedish Election Using a Bayesian State Space Model (Botten Ada)\n\n\nA talk about the undelying Bayesian model that powered “Botten Ada”\n\n\n\nJonas Wallin, Måns Magnusson, Jens Finnäs\n\n\nJun 8, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNowcasting Covid-19 statistics reported with delay. A case-study of Sweden and UK\n\n\nA talk about a Nowcasting model we built for Covid-19 deaths.\n\n\n\nJonas Wallin, Adam Altmejd, Joacim Rocklöv\n\n\nMay 21, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRSS Discussion Meeting, Linear mixed effects models for non-Gaussian continuous repeated measurement data\n\n\nWe present our paper (with dicussion) for the Royal statistical society\n\n\n\nJonas Wallin, Özgür Asar, David Bolin, Peter J Diggle\n\n\nJun 22, 2020\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nScaling of scoring rules\n\n\nA talk about scaling of scoring rules (model evaluation)\n\n\n\nJonas Wallin, David Bolin\n\n\nJun 8, 2020\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "talks/BottenAda/index.html",
    "href": "talks/BottenAda/index.html",
    "title": "Predicting the Swedish Election Using a Bayesian State Space Model (Botten Ada)",
    "section": "",
    "text": "CitationBibTeX citation:@unpublished{wallin2022,\n  author = {Wallin, Jonas and Magnusson, Måns and Finnäs, Jens},\n  title = {Predicting the {Swedish} {Election} {Using} a {Bayesian}\n    {State} {Space} {Model} {(Botten} {Ada)}},\n  date = {2022-06-08},\n  url = {https://www.iffs.se/},\n  langid = {en},\n  abstract = {In the Swedish election 2014 “Botten Ada”, a website using\n    Bayesian modelling and probabilistic machine learning made\n    predictions on the election outcome. In the upcoming Swedish\n    election in the fall, “Botten Ada” and it’s founders, Måns\n    Magnusson, Assistant Professor in statistics at Uppsala University\n    and J++ a data journalism team based in Stockholm, will make a\n    comeback with a new updated and refined model together with Jonas\n    Wallin, Lund University. What degree of accuracy can be reached? And\n    what place can prediction models such as these have in political\n    science, and in academia at large?}\n}\nFor attribution, please cite this work as:\nWallin, Jonas, Måns Magnusson, and Jens Finnäs. 2022. “Predicting\nthe Swedish Election Using a Bayesian State Space Model (Botten\nAda).” Institutet för framtidsstudier, Stockholm, June 8. https://www.iffs.se/."
  },
  {
    "objectID": "publications/index.html",
    "href": "publications/index.html",
    "title": "Publications",
    "section": "",
    "text": "Selected preprints/Accepted\n\n[1] I. Hejn'y, J. Wallin, and M. Bogdan. “Weak pattern recovery for SLOPE and its robust versions”. In: arXiv preprint arXiv:2303.10970 (2023).\n\n\n[2] D. Bolin, A. Simas, and J. Wallin. “Statistical inference for Gaussian Whittle-Matern fields on metric graphs”. In: arXiv preprint arXiv:2304.10372 (2023).\n\n\n[3] D. Bolin, A. B. Simas, and J. Wallin. “Markov properties of Gaussian random fields on compact metric graphs”. In: arXiv preprint arXiv:2304.03190 (2023).\n\n\n[4] Y. Baurne, F. Delmar, and J. Wallin. Modelling Consensus Emergence With Nonlinear Dynamics. Tech. rep. PsyArXiv, 2022.\n\n\n\nArticles\n\n[1] D. Bolin, A. B. Simas, and J. Wallin. “Gaussian Whittle–Matérn fields on metric graphs”. In: Bernoulli (2024).\n\n\n[2] A. L. Ramadona, Y. Tozan, J. Wallin, L. Lazuardi, A. Utarini, and J. Rocklöv. “Predicting the dengue cluster outbreak dynamics in Yogyakarta, Indonesia: a modelling study”. In: The Lancet Regional Health-Southeast Asia (2023).\n\n\n[3] H. Hedlund, H. Du Rietz, J. M. Johansson, H. C. Eriksson, W. Zedan, L. Huang, J. Wallin, and A. Wittrup. “Single-cell quantification and dose-response of cytosolic siRNA delivery”. In: Nature Communications (2023).\n\n\n[4] Z. Farooq, H. Sjödin, J. C. Semenza, Y. Tozan, M. O. Sewe, J. Wallin, and J. Rocklöv. “European projections of West Nile virus transmission under climate change scenarios”. In: One Health (2023).\n\n\n[5] A. Altmejd, J. Rocklöv, and J. Wallin. “Nowcasting COVID-19 Statistics Reported with Delay: A Case-Study of Sweden and the UK”. In: International Journal of Environmental Research and Public Health (2023).\n\n\n[6] Z. Farooq, J. Rocklöv, J. Wallin, N. Abiri, M. O. Sewe, H. Sjödin, and J. C. Semenza. “Artificial intelligence to predict West Nile virus outbreaks with eco-climatic drivers”. In: The Lancet Regional Health-Europe (2022).\n\n\n[7] F. Delmar, J. Wallin, and A. M. Nofal. “Modeling new-firm growth and survival with panel data using event magnitude regression”. In: Journal of Business Venturing (2022).\n\n\n[8] A. Bukartas, J. Wallin, R. Finck, and C. Rääf. “Accuracy of a Bayesian technique to estimate position and activity of orphan gamma-ray sources by mobile gamma spectrometry: Influence of imprecisions in positioning systems and computational approximations”. In: Plos one (2022).\n\n\n[9] D. Bolin and J. Wallin. “Local scale invariance and robustness of proper scoring rules”. In: Statistical Science (2022).\n\n\n[10] J. Wallin, M. Bogdan, P. A. Szulc, R. Doerge, and D. O. Siegmund. “Ghost QTL and hotspots in experimental crosses: novel approach for modeling polygenic effects”. In: Genetics (2021).\n\n\n[11] L. M. McFetridge, Ö. Asar, and J. Wallin. “Robust joint modelling of longitudinal and survival data: Incorporating a time-varying degrees-of-freedom parameter”. In: Biometrical Journal (2021).\n\n\n[12] A. Bukartas, J. Wallin, R. Finck, and C. Rääf. “Bayesian algorithm to estimate position and activity of an orphan gamma source utilizing multiple detectors in a mobile gamma spectrometry system”. In: PloS one (2021).\n\n\n[13] M. T. Parente, J. Wallin, and B. Wohlmuth. “Generalized bounds for active subspaces”. In: Electronic Journal of Statistics (2020).\n\n\n[14] D. Bolin and J. Wallin. “Multivariate type G Matérn stochastic partial differential equation random fields”. In: Journal of the Royal Statistical Society. Series B: Statistical Methodology (2020).\n\n\n[15] Ö. Asar, D. Bolin, P. J. Diggle, and J. Wallin. “Linear mixed effects models for non-Gaussian continuous repeated measurement data”. In: Journal of the Royal Statistical Society: Series C (Applied Statistics) (2020).\n\n\n[16] A. Bukartas, R. Finck, J. Wallin, and C. Rääf. “A Bayesian method to localize lost gamma sources”. In: Applied Radiation and Isotopes (2019).\n\n\n[17] D. Bolin, J. Wallin, and F. Lindgren. “Latent Gaussian random field mixture models”. In: Computational Statistics & Data Analysis (2019).\n\n\n[18] J. Wallin and D. Bolin. “Efficient adaptive MCMC through precision estimation”. In: Journal of Computational and Graphical Statistics (2018).\n\n\n[19] A. Hildeman, D. Bolin, J. Wallin, and J. B. Illian. “Level set Cox processes”. In: Spatial statistics (2018).\n\n\n[20] B. Gunnarsson, J. Wallin, and J. Klingberg. “Predation by avian insectivores on caterpillars is linked to leaf damage on oak (Quercus robur)”. In: Oecologia (2018).\n\n\n[21] K. Podgórski and J. Wallin. “Convolution-invariant subclasses of generalized hyperbolic distributions”. In: Communications in Statistics-Theory and Methods (2016).\n\n\n[22] W. Mao, I. Rychlik, J. Wallin, and G. Storhaug. “Statistical models for the speed prediction of a container ship”. In: Ocean engineering (2016).\n\n\n[23] R. Maghsood, P. Johannesson, and J. Wallin. “Detection of steering events using hidden Markov models with multivariate observations”. In: International Journal of Vehicle Systems Modelling and Testing (2016).\n\n\n[24] K. Johnsson, J. Wallin, and M. Fontes. “BayesFlow: latent modeling of flow cytometry cell populations”. In: BMC bioinformatics (2016).\n\n\n[25] D. Bolin and J. Wallin. “Spatially adaptive covariance tapering”. In: Spatial Statistics (2016).\n\n\n[26] D. Bolin, A. Frigessi, P. Guttorp, O. Haug, E. Orskaug, I. Scheel, and J. Wallin. “Calibrating regionally downscaled precipitation over Norway through quantile-based approaches”. In: Advances in Statistical Climatology, Meteorology and Oceanography (2016).\n\n\n[27] J. Wallin and D. Bolin. “Geostatistical modelling using non-Gaussian Matérn fields”. In: Scandinavian Journal of Statistics (2015).\n\n\n[28] K. Podgórski and J. Wallin. “Maximizing leave-one-out likelihood for the location parameter of unbounded densities”. In: Annals of the Institute of Statistical Mathematics (2015).\n\n\n[29] K. Podgórski, I. Rychlik, and J. Wallin. “Slepian models for moving averages driven by a non-Gaussian noise”. In: Extremes (2015).\n\n\n[30] R. Maghsood, I. Rychlik, and J. Wallin. “Modeling extreme loads acting on steering components using driving events”. In: Probabilistic Engineering Mechanics (2015).\n\n\n[31] S. I. Adalbjörnsson, J. Swärd, J. Wallin, and A. Jakobsson. “Estimating periodicities in symbolic sequences using sparse modeling”. In: IEEE Transactions on Signal Processing (2015).\n\n\n\nProccedings\n\n[1] J. Larsson, Q. Klopfenstein, M. Massias, and J. Wallin. “Coordinate descent for slope”. In: International Conference on Artificial Intelligence and Statistics. PMLR. 2023.\n\n\n[2] Y. Baurne, F. Delmar, J. Wallin, and A. Brattstrom. “How Significant Events and Team Trust Predict Member’s Exit in New Venture Teams”. In: Academy of Management Proceedings. Academy of Management Briarcliff Manor, NY 10510. 2023.\n\n\n[3] J. Larsson and J. Wallin. “The Hessian Screening Rule”. In: Advances in Neural Information Processing Systems. 2022.\n\n\n[4] D. Bolin and J. Wallin. “Efficient methods for Gaussian Markov random fields under sparse linear constraints”. In: Advances in Neural Information Processing Systems. 2021.\n\n\n[5] J. Larsson, M. Bogdan, and J. Wallin. “The Strong Screening Rule for SLOPE”. In: Advances in Neural Information Processing Systems. Ed. by H. Larochelle, M. Ranzato, R. Hadsell, M. Balcan and H. Lin. Curran Associates, Inc., 2020.\n\n\n[6] F. Delmar and J. Wallin. “Modelling new firm growth and survival: Some practical solutions”. In: Academy of Management Proceedings. Academy of Management Briarcliff Manor, NY 10510. 2018."
  },
  {
    "objectID": "talks/Nowcasting_Covid/index.html",
    "href": "talks/Nowcasting_Covid/index.html",
    "title": "Nowcasting Covid-19 statistics reported with delay. A case-study of Sweden and UK",
    "section": "",
    "text": "&lt;/p&gt;\n&lt;div id=\"quarto-navigation-envelope\" class=\"hidden\"&gt;\n&lt;p&gt;&lt;span class=\"hidden\" data-render-id=\"quarto-int-sidebar-title\"&gt;Jonas Wallin&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-int-navbar-title\"&gt;Jonas Wallin&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-int-navbar:Publications\"&gt;Publications&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-int-navbar:/publications/index.html\"&gt;/publications/index.html&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-int-navbar:Online talks\"&gt;Online talks&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-int-navbar:/talks/index.html\"&gt;/talks/index.html&lt;/span&gt;&lt;/p&gt;\n&lt;div class=\"hidden\" data-render-id=\"footer-left-Copyright 2023, Jonas Wallin\"&gt;\n&lt;p&gt;Copyright 2023, Jonas Wallin&lt;/p&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;div id=\"quarto-meta-markdown\" class=\"hidden\"&gt;\n&lt;p&gt;&lt;span class=\"hidden\" data-render-id=\"quarto-metatitle\"&gt;Jonas Wallin - Nowcasting Covid-19 statistics reported with delay. A case-study of Sweden and UK&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-twittercardtitle\"&gt;Jonas Wallin - Nowcasting Covid-19 statistics reported with delay. A case-study of Sweden and UK&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-ogcardtitle\"&gt;Jonas Wallin - Nowcasting Covid-19 statistics reported with delay. A case-study of Sweden and UK&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-metasitename\"&gt;Jonas Wallin&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-twittercarddesc\"&gt;A talk about a Nowcasting model we built for Covid-19 deaths.&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-ogcardddesc\"&gt;A talk about a Nowcasting model we built for Covid-19 deaths.&lt;/span&gt;&lt;/p&gt;\n&lt;/div&gt;\n\n&lt;/main&gt; &lt;!-- /main --&gt;\n&lt;script id = \"quarto-html-after-body\" type=\"application/javascript\"&gt;\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const toggleBodyColorMode = (bsSheetEl) =&gt; {\n    const mode = bsSheetEl.getAttribute(\"data-mode\");\n    const bodyEl = window.document.querySelector(\"body\");\n    if (mode === \"dark\") {\n      bodyEl.classList.add(\"quarto-dark\");\n      bodyEl.classList.remove(\"quarto-light\");\n    } else {\n      bodyEl.classList.add(\"quarto-light\");\n      bodyEl.classList.remove(\"quarto-dark\");\n    }\n  }\n  const toggleBodyColorPrimary = () =&gt; {\n    const bsSheetEl = window.document.querySelector(\"link#quarto-bootstrap\");\n    if (bsSheetEl) {\n      toggleBodyColorMode(bsSheetEl);\n    }\n  }\n  toggleBodyColorPrimary();  \n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const isCodeAnnotation = (el) =&gt; {\n    for (const clz of el.classList) {\n      if (clz.startsWith('code-annotation-')) {                     \n        return true;\n      }\n    }\n    return false;\n  }\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    text: function(trigger) {\n      const codeEl = trigger.previousElementSibling.cloneNode(true);\n      for (const childEl of codeEl.children) {\n        if (isCodeAnnotation(childEl)) {\n          childEl.remove();\n        }\n      }\n      return codeEl.innerText;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    var currentTitle = button.getAttribute(\"title\");\n    button.setAttribute(\"title\", \"Copied!\");\n    let tooltip;\n    if (window.bootstrap) {\n      button.setAttribute(\"data-bs-toggle\", \"tooltip\");\n      button.setAttribute(\"data-bs-placement\", \"left\");\n      button.setAttribute(\"data-bs-title\", \"Copied!\");\n      tooltip = new bootstrap.Tooltip(button, \n        { trigger: \"manual\", \n          customClass: \"code-copy-button-tooltip\",\n          offset: [0, -8]});\n      tooltip.show();    \n    }\n    setTimeout(function() {\n      if (tooltip) {\n        tooltip.hide();\n        button.removeAttribute(\"data-bs-title\");\n        button.removeAttribute(\"data-bs-toggle\");\n        button.removeAttribute(\"data-bs-placement\");\n      }\n      button.setAttribute(\"title\", currentTitle);\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {\n    const config = {\n      allowHTML: true,\n      maxWidth: 500,\n      delay: 100,\n      arrow: false,\n      appendTo: function(el) {\n          return el.parentElement;\n      },\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start',\n    };\n    if (contentFn) {\n      config.content = contentFn;\n    }\n    if (onTriggerFn) {\n      config.onTrigger = onTriggerFn;\n    }\n    if (onUntriggerFn) {\n      config.onUntrigger = onUntriggerFn;\n    }\n    window.tippy(el, config); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i&lt;noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      // use id or data attribute instead here\n      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');\n      try { href = new URL(href).hash; } catch {}\n      const id = href.replace(/^#\\/?/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  const xrefs = window.document.querySelectorAll('a.quarto-xref');\n  const processXRef = (id, note) =&gt; {\n    // Strip column container classes\n    const stripColumnClz = (el) =&gt; {\n      el.classList.remove(\"page-full\", \"page-columns\");\n      if (el.children) {\n        for (const child of el.children) {\n          stripColumnClz(child);\n        }\n      }\n    }\n    stripColumnClz(note)\n    if (id === null || id.startsWith('sec-')) {\n      // Special case sections, only their first couple elements\n      const container = document.createElement(\"div\");\n      if (note.children && note.children.length &gt; 2) {\n        container.appendChild(note.children[0].cloneNode(true));\n        for (let i = 1; i &lt; note.children.length; i++) {\n          const child = note.children[i];\n          if (child.tagName === \"P\" && child.innerText === \"\") {\n            continue;\n          } else {\n            container.appendChild(child.cloneNode(true));\n            break;\n          }\n        }\n        if (window.Quarto?.typesetMath) {\n          window.Quarto.typesetMath(container);\n        }\n        return container.innerHTML\n      } else {\n        if (window.Quarto?.typesetMath) {\n          window.Quarto.typesetMath(note);\n        }\n        return note.innerHTML;\n      }\n    } else {\n      // Remove any anchor links if they are present\n      const anchorLink = note.querySelector('a.anchorjs-link');\n      if (anchorLink) {\n        anchorLink.remove();\n      }\n      if (window.Quarto?.typesetMath) {\n        window.Quarto.typesetMath(note);\n      }\n      // TODO in 1.5, we should make sure this works without a callout special case\n      if (note.classList.contains(\"callout\")) {\n        return note.outerHTML;\n      } else {\n        return note.innerHTML;\n      }\n    }\n  }\n  for (var i=0; i&lt;xrefs.length; i++) {\n    const xref = xrefs[i];\n    tippyHover(xref, undefined, function(instance) {\n      instance.disable();\n      let url = xref.getAttribute('href');\n      let hash = undefined; \n      if (url.startsWith('#')) {\n        hash = url;\n      } else {\n        try { hash = new URL(url).hash; } catch {}\n      }\n      if (hash) {\n        const id = hash.replace(/^#\\/?/, \"\");\n        const note = window.document.getElementById(id);\n        if (note !== null) {\n          try {\n            const html = processXRef(id, note.cloneNode(true));\n            instance.setContent(html);\n          } finally {\n            instance.enable();\n            instance.show();\n          }\n        } else {\n          // See if we can fetch this\n          fetch(url.split('#')[0])\n          .then(res =&gt; res.text())\n          .then(html =&gt; {\n            const parser = new DOMParser();\n            const htmlDoc = parser.parseFromString(html, \"text/html\");\n            const note = htmlDoc.getElementById(id);\n            if (note !== null) {\n              const html = processXRef(id, note);\n              instance.setContent(html);\n            } \n          }).finally(() =&gt; {\n            instance.enable();\n            instance.show();\n          });\n        }\n      } else {\n        // See if we can fetch a full url (with no hash to target)\n        // This is a special case and we should probably do some content thinning / targeting\n        fetch(url)\n        .then(res =&gt; res.text())\n        .then(html =&gt; {\n          const parser = new DOMParser();\n          const htmlDoc = parser.parseFromString(html, \"text/html\");\n          const note = htmlDoc.querySelector('main.content');\n          if (note !== null) {\n            // This should only happen for chapter cross references\n            // (since there is no id in the URL)\n            // remove the first header\n            if (note.children.length &gt; 0 && note.children[0].tagName === \"HEADER\") {\n              note.children[0].remove();\n            }\n            const html = processXRef(null, note);\n            instance.setContent(html);\n          } \n        }).finally(() =&gt; {\n          instance.enable();\n          instance.show();\n        });\n      }\n    }, function(instance) {\n    });\n  }\n      let selectedAnnoteEl;\n      const selectorForAnnotation = ( cell, annotation) =&gt; {\n        let cellAttr = 'data-code-cell=\"' + cell + '\"';\n        let lineAttr = 'data-code-annotation=\"' +  annotation + '\"';\n        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';\n        return selector;\n      }\n      const selectCodeLines = (annoteEl) =&gt; {\n        const doc = window.document;\n        const targetCell = annoteEl.getAttribute(\"data-target-cell\");\n        const targetAnnotation = annoteEl.getAttribute(\"data-target-annotation\");\n        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));\n        const lines = annoteSpan.getAttribute(\"data-code-lines\").split(\",\");\n        const lineIds = lines.map((line) =&gt; {\n          return targetCell + \"-\" + line;\n        })\n        let top = null;\n        let height = null;\n        let parent = null;\n        if (lineIds.length &gt; 0) {\n            //compute the position of the single el (top and bottom and make a div)\n            const el = window.document.getElementById(lineIds[0]);\n            top = el.offsetTop;\n            height = el.offsetHeight;\n            parent = el.parentElement.parentElement;\n          if (lineIds.length &gt; 1) {\n            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);\n            const bottom = lastEl.offsetTop + lastEl.offsetHeight;\n            height = bottom - top;\n          }\n          if (top !== null && height !== null && parent !== null) {\n            // cook up a div (if necessary) and position it \n            let div = window.document.getElementById(\"code-annotation-line-highlight\");\n            if (div === null) {\n              div = window.document.createElement(\"div\");\n              div.setAttribute(\"id\", \"code-annotation-line-highlight\");\n              div.style.position = 'absolute';\n              parent.appendChild(div);\n            }\n            div.style.top = top - 2 + \"px\";\n            div.style.height = height + 4 + \"px\";\n            div.style.left = 0;\n            let gutterDiv = window.document.getElementById(\"code-annotation-line-highlight-gutter\");\n            if (gutterDiv === null) {\n              gutterDiv = window.document.createElement(\"div\");\n              gutterDiv.setAttribute(\"id\", \"code-annotation-line-highlight-gutter\");\n              gutterDiv.style.position = 'absolute';\n              const codeCell = window.document.getElementById(targetCell);\n              const gutter = codeCell.querySelector('.code-annotation-gutter');\n              gutter.appendChild(gutterDiv);\n            }\n            gutterDiv.style.top = top - 2 + \"px\";\n            gutterDiv.style.height = height + 4 + \"px\";\n          }\n          selectedAnnoteEl = annoteEl;\n        }\n      };\n      const unselectCodeLines = () =&gt; {\n        const elementsIds = [\"code-annotation-line-highlight\", \"code-annotation-line-highlight-gutter\"];\n        elementsIds.forEach((elId) =&gt; {\n          const div = window.document.getElementById(elId);\n          if (div) {\n            div.remove();\n          }\n        });\n        selectedAnnoteEl = undefined;\n      };\n        // Handle positioning of the toggle\n    window.addEventListener(\n      \"resize\",\n      throttle(() =&gt; {\n        elRect = undefined;\n        if (selectedAnnoteEl) {\n          selectCodeLines(selectedAnnoteEl);\n        }\n      }, 10)\n    );\n    function throttle(fn, ms) {\n    let throttle = false;\n    let timer;\n      return (...args) =&gt; {\n        if(!throttle) { // first call gets through\n            fn.apply(this, args);\n            throttle = true;\n        } else { // all the others get throttled\n            if(timer) clearTimeout(timer); // cancel #2\n            timer = setTimeout(() =&gt; {\n              fn.apply(this, args);\n              timer = throttle = false;\n            }, ms);\n        }\n      };\n    }\n      // Attach click handler to the DT\n      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');\n      for (const annoteDlNode of annoteDls) {\n        annoteDlNode.addEventListener('click', (event) =&gt; {\n          const clickedEl = event.target;\n          if (clickedEl !== selectedAnnoteEl) {\n            unselectCodeLines();\n            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');\n            if (activeEl) {\n              activeEl.classList.remove('code-annotation-active');\n            }\n            selectCodeLines(clickedEl);\n            clickedEl.classList.add('code-annotation-active');\n          } else {\n            // Unselect the line\n            unselectCodeLines();\n            clickedEl.classList.remove('code-annotation-active');\n          }\n        });\n      }\n  const findCites = (el) =&gt; {\n    const parentEl = el.parentElement;\n    if (parentEl) {\n      const cites = parentEl.dataset.cites;\n      if (cites) {\n        return {\n          el,\n          cites: cites.split(' ')\n        };\n      } else {\n        return findCites(el.parentElement)\n      }\n    } else {\n      return undefined;\n    }\n  };\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i&lt;bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const citeInfo = findCites(ref);\n    if (citeInfo) {\n      tippyHover(citeInfo.el, function() {\n        var popup = window.document.createElement('div');\n        citeInfo.cites.forEach(function(cite) {\n          var citeDiv = window.document.createElement('div');\n          citeDiv.classList.add('hanging-indent');\n          citeDiv.classList.add('csl-entry');\n          var biblioDiv = window.document.getElementById('ref-' + cite);\n          if (biblioDiv) {\n            citeDiv.innerHTML = biblioDiv.innerHTML;\n          }\n          popup.appendChild(citeDiv);\n        });\n        return popup.innerHTML;\n      });\n    }\n  }\n});\n&lt;/script&gt;\n&lt;/div&gt; &lt;!-- /content --&gt;\n&lt;footer class=\"footer\"&gt;\n  &lt;div class=\"nav-footer\"&gt;\n    &lt;div class=\"nav-footer-left\"&gt;\n      &lt;ul class=\"footer-items list-unstyled\"&gt;\n    &lt;li class=\"nav-item\"&gt;\n Copyright 2023, Jonas Wallin\n  &lt;/li&gt;  \n&lt;/ul&gt;\n    &lt;/div&gt;   \n    &lt;div class=\"nav-footer-center\"&gt;\n      &nbsp;\n    &lt;/div&gt;\n    &lt;div class=\"nav-footer-right\"&gt;\n      &lt;ul class=\"footer-items list-unstyled\"&gt;\n    &lt;li class=\"nav-item compact\"&gt;\n    &lt;a class=\"nav-link\" href=\"https://github.com/JonasWallin\"&gt;\n      &lt;i \n  class=\"bi bi-github\" \n  role=\"img\" \n&gt;\n&lt;/i&gt; \n    &lt;/a&gt;\n  &lt;/li&gt;  \n&lt;/ul&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/footer&gt;\n\n\n&lt;/body&gt;\n\n&lt;/html&gt;\nCitationBibTeX citation:@unpublished{wallin2021,\n  author = {Wallin, Jonas and Altmejd, Adam and Rocklöv, Joacim},\n  title = {Nowcasting {Covid-19} Statistics Reported with Delay. {A}\n    Case-Study of {Sweden} and {UK}},\n  date = {2021-05-21},\n  url = {https://www.youtube.com/embed/RHLPu389PNY},\n  langid = {en},\n  abstract = {Monitoring the progress of the Coronavirus is crucial for\n    timely implementation of intervention. The availability of unbiased\n    timely statistics of trends in disease events are a key to effective\n    responses. But due to reporting delays, the most recently reported\n    numbers are frequently underestimating the total number of\n    infections, hospitalizations and deaths creating an illusion of a\n    downward trend. Here we describe a statistical methodology for\n    predicting true daily quantities and their uncertainty, estimated\n    using historical reporting delays. The methodology takes into\n    account the observed distribution pattern of the lag. It is derived\n    from the “removal method”, a well-established estimation framework\n    in the field of ecology. We show how the method works for both the\n    Swedish and the UK death count.}\n}\nFor attribution, please cite this work as:\nWallin, Jonas, Adam Altmejd, and Joacim Rocklöv. 2021. “Nowcasting\nCovid-19 Statistics Reported with Delay. A Case-Study of Sweden and\nUK.” Online, Online, May 21. https://www.youtube.com/embed/RHLPu389PNY."
  },
  {
    "objectID": "talks/Non Gaussian Mixed Model/index.html",
    "href": "talks/Non Gaussian Mixed Model/index.html",
    "title": "RSS Discussion Meeting, Linear mixed effects models for non-Gaussian continuous repeated measurement data",
    "section": "",
    "text": "&lt;div id=\"quarto-navigation-envelope\" class=\"hidden\"&gt;\n&lt;p&gt;&lt;span class=\"hidden\" data-render-id=\"quarto-int-sidebar-title\"&gt;Jonas Wallin&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-int-navbar-title\"&gt;Jonas Wallin&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-int-navbar:Publications\"&gt;Publications&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-int-navbar:/publications/index.html\"&gt;/publications/index.html&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-int-navbar:Online talks\"&gt;Online talks&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-int-navbar:/talks/index.html\"&gt;/talks/index.html&lt;/span&gt;&lt;/p&gt;\n&lt;div class=\"hidden\" data-render-id=\"footer-left-Copyright 2023, Jonas Wallin\"&gt;\n&lt;p&gt;Copyright 2023, Jonas Wallin&lt;/p&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;div id=\"quarto-meta-markdown\" class=\"hidden\"&gt;\n&lt;p&gt;&lt;span class=\"hidden\" data-render-id=\"quarto-metatitle\"&gt;Jonas Wallin - RSS Discussion Meeting, Linear mixed effects models for non-Gaussian continuous repeated measurement data&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-twittercardtitle\"&gt;Jonas Wallin - RSS Discussion Meeting, Linear mixed effects models for non-Gaussian continuous repeated measurement data&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-ogcardtitle\"&gt;Jonas Wallin - RSS Discussion Meeting, Linear mixed effects models for non-Gaussian continuous repeated measurement data&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-metasitename\"&gt;Jonas Wallin&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-twittercarddesc\"&gt;We present our paper (with dicussion) for the Royal statistical society&lt;/span&gt; &lt;span class=\"hidden\" data-render-id=\"quarto-ogcardddesc\"&gt;We present our paper (with dicussion) for the Royal statistical society&lt;/span&gt;&lt;/p&gt;\n&lt;/div&gt;\n\n&lt;/main&gt; &lt;!-- /main --&gt;\n&lt;script id = \"quarto-html-after-body\" type=\"application/javascript\"&gt;\nwindow.document.addEventListener(\"DOMContentLoaded\", function (event) {\n  const toggleBodyColorMode = (bsSheetEl) =&gt; {\n    const mode = bsSheetEl.getAttribute(\"data-mode\");\n    const bodyEl = window.document.querySelector(\"body\");\n    if (mode === \"dark\") {\n      bodyEl.classList.add(\"quarto-dark\");\n      bodyEl.classList.remove(\"quarto-light\");\n    } else {\n      bodyEl.classList.add(\"quarto-light\");\n      bodyEl.classList.remove(\"quarto-dark\");\n    }\n  }\n  const toggleBodyColorPrimary = () =&gt; {\n    const bsSheetEl = window.document.querySelector(\"link#quarto-bootstrap\");\n    if (bsSheetEl) {\n      toggleBodyColorMode(bsSheetEl);\n    }\n  }\n  toggleBodyColorPrimary();  \n  const icon = \"\";\n  const anchorJS = new window.AnchorJS();\n  anchorJS.options = {\n    placement: 'right',\n    icon: icon\n  };\n  anchorJS.add('.anchored');\n  const isCodeAnnotation = (el) =&gt; {\n    for (const clz of el.classList) {\n      if (clz.startsWith('code-annotation-')) {                     \n        return true;\n      }\n    }\n    return false;\n  }\n  const clipboard = new window.ClipboardJS('.code-copy-button', {\n    text: function(trigger) {\n      const codeEl = trigger.previousElementSibling.cloneNode(true);\n      for (const childEl of codeEl.children) {\n        if (isCodeAnnotation(childEl)) {\n          childEl.remove();\n        }\n      }\n      return codeEl.innerText;\n    }\n  });\n  clipboard.on('success', function(e) {\n    // button target\n    const button = e.trigger;\n    // don't keep focus\n    button.blur();\n    // flash \"checked\"\n    button.classList.add('code-copy-button-checked');\n    var currentTitle = button.getAttribute(\"title\");\n    button.setAttribute(\"title\", \"Copied!\");\n    let tooltip;\n    if (window.bootstrap) {\n      button.setAttribute(\"data-bs-toggle\", \"tooltip\");\n      button.setAttribute(\"data-bs-placement\", \"left\");\n      button.setAttribute(\"data-bs-title\", \"Copied!\");\n      tooltip = new bootstrap.Tooltip(button, \n        { trigger: \"manual\", \n          customClass: \"code-copy-button-tooltip\",\n          offset: [0, -8]});\n      tooltip.show();    \n    }\n    setTimeout(function() {\n      if (tooltip) {\n        tooltip.hide();\n        button.removeAttribute(\"data-bs-title\");\n        button.removeAttribute(\"data-bs-toggle\");\n        button.removeAttribute(\"data-bs-placement\");\n      }\n      button.setAttribute(\"title\", currentTitle);\n      button.classList.remove('code-copy-button-checked');\n    }, 1000);\n    // clear code selection\n    e.clearSelection();\n  });\n  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {\n    const config = {\n      allowHTML: true,\n      maxWidth: 500,\n      delay: 100,\n      arrow: false,\n      appendTo: function(el) {\n          return el.parentElement;\n      },\n      interactive: true,\n      interactiveBorder: 10,\n      theme: 'quarto',\n      placement: 'bottom-start',\n    };\n    if (contentFn) {\n      config.content = contentFn;\n    }\n    if (onTriggerFn) {\n      config.onTrigger = onTriggerFn;\n    }\n    if (onUntriggerFn) {\n      config.onUntrigger = onUntriggerFn;\n    }\n    window.tippy(el, config); \n  }\n  const noterefs = window.document.querySelectorAll('a[role=\"doc-noteref\"]');\n  for (var i=0; i&lt;noterefs.length; i++) {\n    const ref = noterefs[i];\n    tippyHover(ref, function() {\n      // use id or data attribute instead here\n      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');\n      try { href = new URL(href).hash; } catch {}\n      const id = href.replace(/^#\\/?/, \"\");\n      const note = window.document.getElementById(id);\n      return note.innerHTML;\n    });\n  }\n  const xrefs = window.document.querySelectorAll('a.quarto-xref');\n  const processXRef = (id, note) =&gt; {\n    // Strip column container classes\n    const stripColumnClz = (el) =&gt; {\n      el.classList.remove(\"page-full\", \"page-columns\");\n      if (el.children) {\n        for (const child of el.children) {\n          stripColumnClz(child);\n        }\n      }\n    }\n    stripColumnClz(note)\n    if (id === null || id.startsWith('sec-')) {\n      // Special case sections, only their first couple elements\n      const container = document.createElement(\"div\");\n      if (note.children && note.children.length &gt; 2) {\n        container.appendChild(note.children[0].cloneNode(true));\n        for (let i = 1; i &lt; note.children.length; i++) {\n          const child = note.children[i];\n          if (child.tagName === \"P\" && child.innerText === \"\") {\n            continue;\n          } else {\n            container.appendChild(child.cloneNode(true));\n            break;\n          }\n        }\n        if (window.Quarto?.typesetMath) {\n          window.Quarto.typesetMath(container);\n        }\n        return container.innerHTML\n      } else {\n        if (window.Quarto?.typesetMath) {\n          window.Quarto.typesetMath(note);\n        }\n        return note.innerHTML;\n      }\n    } else {\n      // Remove any anchor links if they are present\n      const anchorLink = note.querySelector('a.anchorjs-link');\n      if (anchorLink) {\n        anchorLink.remove();\n      }\n      if (window.Quarto?.typesetMath) {\n        window.Quarto.typesetMath(note);\n      }\n      // TODO in 1.5, we should make sure this works without a callout special case\n      if (note.classList.contains(\"callout\")) {\n        return note.outerHTML;\n      } else {\n        return note.innerHTML;\n      }\n    }\n  }\n  for (var i=0; i&lt;xrefs.length; i++) {\n    const xref = xrefs[i];\n    tippyHover(xref, undefined, function(instance) {\n      instance.disable();\n      let url = xref.getAttribute('href');\n      let hash = undefined; \n      if (url.startsWith('#')) {\n        hash = url;\n      } else {\n        try { hash = new URL(url).hash; } catch {}\n      }\n      if (hash) {\n        const id = hash.replace(/^#\\/?/, \"\");\n        const note = window.document.getElementById(id);\n        if (note !== null) {\n          try {\n            const html = processXRef(id, note.cloneNode(true));\n            instance.setContent(html);\n          } finally {\n            instance.enable();\n            instance.show();\n          }\n        } else {\n          // See if we can fetch this\n          fetch(url.split('#')[0])\n          .then(res =&gt; res.text())\n          .then(html =&gt; {\n            const parser = new DOMParser();\n            const htmlDoc = parser.parseFromString(html, \"text/html\");\n            const note = htmlDoc.getElementById(id);\n            if (note !== null) {\n              const html = processXRef(id, note);\n              instance.setContent(html);\n            } \n          }).finally(() =&gt; {\n            instance.enable();\n            instance.show();\n          });\n        }\n      } else {\n        // See if we can fetch a full url (with no hash to target)\n        // This is a special case and we should probably do some content thinning / targeting\n        fetch(url)\n        .then(res =&gt; res.text())\n        .then(html =&gt; {\n          const parser = new DOMParser();\n          const htmlDoc = parser.parseFromString(html, \"text/html\");\n          const note = htmlDoc.querySelector('main.content');\n          if (note !== null) {\n            // This should only happen for chapter cross references\n            // (since there is no id in the URL)\n            // remove the first header\n            if (note.children.length &gt; 0 && note.children[0].tagName === \"HEADER\") {\n              note.children[0].remove();\n            }\n            const html = processXRef(null, note);\n            instance.setContent(html);\n          } \n        }).finally(() =&gt; {\n          instance.enable();\n          instance.show();\n        });\n      }\n    }, function(instance) {\n    });\n  }\n      let selectedAnnoteEl;\n      const selectorForAnnotation = ( cell, annotation) =&gt; {\n        let cellAttr = 'data-code-cell=\"' + cell + '\"';\n        let lineAttr = 'data-code-annotation=\"' +  annotation + '\"';\n        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';\n        return selector;\n      }\n      const selectCodeLines = (annoteEl) =&gt; {\n        const doc = window.document;\n        const targetCell = annoteEl.getAttribute(\"data-target-cell\");\n        const targetAnnotation = annoteEl.getAttribute(\"data-target-annotation\");\n        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));\n        const lines = annoteSpan.getAttribute(\"data-code-lines\").split(\",\");\n        const lineIds = lines.map((line) =&gt; {\n          return targetCell + \"-\" + line;\n        })\n        let top = null;\n        let height = null;\n        let parent = null;\n        if (lineIds.length &gt; 0) {\n            //compute the position of the single el (top and bottom and make a div)\n            const el = window.document.getElementById(lineIds[0]);\n            top = el.offsetTop;\n            height = el.offsetHeight;\n            parent = el.parentElement.parentElement;\n          if (lineIds.length &gt; 1) {\n            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);\n            const bottom = lastEl.offsetTop + lastEl.offsetHeight;\n            height = bottom - top;\n          }\n          if (top !== null && height !== null && parent !== null) {\n            // cook up a div (if necessary) and position it \n            let div = window.document.getElementById(\"code-annotation-line-highlight\");\n            if (div === null) {\n              div = window.document.createElement(\"div\");\n              div.setAttribute(\"id\", \"code-annotation-line-highlight\");\n              div.style.position = 'absolute';\n              parent.appendChild(div);\n            }\n            div.style.top = top - 2 + \"px\";\n            div.style.height = height + 4 + \"px\";\n            div.style.left = 0;\n            let gutterDiv = window.document.getElementById(\"code-annotation-line-highlight-gutter\");\n            if (gutterDiv === null) {\n              gutterDiv = window.document.createElement(\"div\");\n              gutterDiv.setAttribute(\"id\", \"code-annotation-line-highlight-gutter\");\n              gutterDiv.style.position = 'absolute';\n              const codeCell = window.document.getElementById(targetCell);\n              const gutter = codeCell.querySelector('.code-annotation-gutter');\n              gutter.appendChild(gutterDiv);\n            }\n            gutterDiv.style.top = top - 2 + \"px\";\n            gutterDiv.style.height = height + 4 + \"px\";\n          }\n          selectedAnnoteEl = annoteEl;\n        }\n      };\n      const unselectCodeLines = () =&gt; {\n        const elementsIds = [\"code-annotation-line-highlight\", \"code-annotation-line-highlight-gutter\"];\n        elementsIds.forEach((elId) =&gt; {\n          const div = window.document.getElementById(elId);\n          if (div) {\n            div.remove();\n          }\n        });\n        selectedAnnoteEl = undefined;\n      };\n        // Handle positioning of the toggle\n    window.addEventListener(\n      \"resize\",\n      throttle(() =&gt; {\n        elRect = undefined;\n        if (selectedAnnoteEl) {\n          selectCodeLines(selectedAnnoteEl);\n        }\n      }, 10)\n    );\n    function throttle(fn, ms) {\n    let throttle = false;\n    let timer;\n      return (...args) =&gt; {\n        if(!throttle) { // first call gets through\n            fn.apply(this, args);\n            throttle = true;\n        } else { // all the others get throttled\n            if(timer) clearTimeout(timer); // cancel #2\n            timer = setTimeout(() =&gt; {\n              fn.apply(this, args);\n              timer = throttle = false;\n            }, ms);\n        }\n      };\n    }\n      // Attach click handler to the DT\n      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');\n      for (const annoteDlNode of annoteDls) {\n        annoteDlNode.addEventListener('click', (event) =&gt; {\n          const clickedEl = event.target;\n          if (clickedEl !== selectedAnnoteEl) {\n            unselectCodeLines();\n            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');\n            if (activeEl) {\n              activeEl.classList.remove('code-annotation-active');\n            }\n            selectCodeLines(clickedEl);\n            clickedEl.classList.add('code-annotation-active');\n          } else {\n            // Unselect the line\n            unselectCodeLines();\n            clickedEl.classList.remove('code-annotation-active');\n          }\n        });\n      }\n  const findCites = (el) =&gt; {\n    const parentEl = el.parentElement;\n    if (parentEl) {\n      const cites = parentEl.dataset.cites;\n      if (cites) {\n        return {\n          el,\n          cites: cites.split(' ')\n        };\n      } else {\n        return findCites(el.parentElement)\n      }\n    } else {\n      return undefined;\n    }\n  };\n  var bibliorefs = window.document.querySelectorAll('a[role=\"doc-biblioref\"]');\n  for (var i=0; i&lt;bibliorefs.length; i++) {\n    const ref = bibliorefs[i];\n    const citeInfo = findCites(ref);\n    if (citeInfo) {\n      tippyHover(citeInfo.el, function() {\n        var popup = window.document.createElement('div');\n        citeInfo.cites.forEach(function(cite) {\n          var citeDiv = window.document.createElement('div');\n          citeDiv.classList.add('hanging-indent');\n          citeDiv.classList.add('csl-entry');\n          var biblioDiv = window.document.getElementById('ref-' + cite);\n          if (biblioDiv) {\n            citeDiv.innerHTML = biblioDiv.innerHTML;\n          }\n          popup.appendChild(citeDiv);\n        });\n        return popup.innerHTML;\n      });\n    }\n  }\n});\n&lt;/script&gt;\n&lt;/div&gt; &lt;!-- /content --&gt;\n&lt;footer class=\"footer\"&gt;\n  &lt;div class=\"nav-footer\"&gt;\n    &lt;div class=\"nav-footer-left\"&gt;\n      &lt;ul class=\"footer-items list-unstyled\"&gt;\n    &lt;li class=\"nav-item\"&gt;\n Copyright 2023, Jonas Wallin\n  &lt;/li&gt;  \n&lt;/ul&gt;\n    &lt;/div&gt;   \n    &lt;div class=\"nav-footer-center\"&gt;\n      &nbsp;\n    &lt;/div&gt;\n    &lt;div class=\"nav-footer-right\"&gt;\n      &lt;ul class=\"footer-items list-unstyled\"&gt;\n    &lt;li class=\"nav-item compact\"&gt;\n    &lt;a class=\"nav-link\" href=\"https://github.com/JonasWallin\"&gt;\n      &lt;i \n  class=\"bi bi-github\" \n  role=\"img\" \n&gt;\n&lt;/i&gt; \n    &lt;/a&gt;\n  &lt;/li&gt;  \n&lt;/ul&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/footer&gt;\n\n\n&lt;/body&gt;\n\n&lt;/html&gt;\nCitationBibTeX citation:@unpublished{wallin2020,\n  author = {Wallin, Jonas and Asar, Özgür and Bolin, David and J Diggle,\n    Peter},\n  title = {RSS {Discussion} {Meeting,} {Linear} Mixed Effects Models for\n    {non-Gaussian} Continuous Repeated Measurement Data},\n  date = {2020-06-22},\n  url = {https://www.youtube.com/embed/olSFzM-JUtU},\n  langid = {en},\n  abstract = {We consider the analysis of continuous repeated\n    measurement outcomes that are collected longitudinally. A standard\n    framework for analysing data of this kind is a linear Gaussian mixed\n    effects model within which the outcome variable can be decomposed\n    into fixed effects, time invariant and time-varying random effects,\n    and measurement noise. We develop methodology that, for the first\n    time, allows any combination of these stochastic components to be\n    non-Gaussian, using multivariate normal variance–mean mixtures. To\n    meet the computational challenges that are presented by large data\n    sets, i.e. in the current context, data sets with many subjects\n    and/or many repeated measurements per subject, we propose a novel\n    implementation of maximum likelihood estimation using a\n    computationally efficient subsampling-based stochastic gradient\n    algorithm. We obtain standard error estimates by inverting the\n    observed Fisher information matrix and obtain the predictive\n    distributions for the random effects in both filtering (conditioning\n    on past and current data) and smoothing (conditioning on all data)\n    contexts. To implement these procedures, we introduce an R package\n    ngme. We reanalyse two data sets, from cystic fibrosis and\n    nephrology research, that were previously analysed by using Gaussian\n    linear mixed effects models.}\n}\nFor attribution, please cite this work as:\nWallin, Jonas, Özgür Asar, David Bolin, and Peter J Diggle. 2020.\n“RSS Discussion Meeting, Linear Mixed Effects Models for\nNon-Gaussian Continuous Repeated Measurement Data.” Online,\nOnline, June 22. https://www.youtube.com/embed/olSFzM-JUtU."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Jonas Wallin",
    "section": "",
    "text": "Associate Professor in Statistics at the Department of Statistics at Lund University, Sweden."
  }
]